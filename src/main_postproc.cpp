//------------------------------------------------------------------------------------------------------------
//! \file   main_postproc.cpp
//! \brief  Contains the main driver function for post-processing of solver outputs.
//!
//! The routines RunType(), Order(), Angles(), Cells(), and RunName() assume that \pp{filename} has the form
//! > (<i>runtype</i>)_ord(<i>order</i>)_q(<i>angles</i>)_nx(<i>cells</i>).*
//! where
//!     - (<i>runtype</i>)  is one of C, H#, U (for collided, hybrid types, and uncollided).
//!     - (<i>order</i>)    is an integer.
//!     - (<i>angles</i>)   is an integer or takes the form #-# for two integers.
//!     - (<i>cells</i>)    is an integer.
//!
//! These routines are used by the SD_dataTable() and AF_dataTable() routines to parse a variety of output
//! files generated by different types of runs.
//!
//! \authors    Michael M. Crockatt
//! \date       February 2018
//------------------------------------------------------------------------------------------------------------

# include <algorithm>
# include <cinttypes>
# include <cmath>
# include <cstring>
# include <fstream>
# include <iomanip>
# include <iostream>
# include <sstream>
# include <string>
# include <vector>

# include <dirent.h>
# include <sys/stat.h>
# include <sysexits.h>

# if defined (ENABLE_MPI) || defined (DOXYCOMPILE)
    # include <mpi.h>
# endif

# include "sha.h"

# include "objects/RKDG/DensityFunction.hpp"
# include "objects/RKDG/OrdinateFlux.hpp"
# include "operators/RelabelOperator.hpp"
# include "utils/CLog.hpp"
# include "utils/NDArray.hpp"


using namespace RKDG;


int s_MPI_num_blocks [SPACE_DIMS] =
                                # if SPACE_DIMS == 1
                                    {1};
                                # elif SPACE_DIMS == 2
                                    {1,1};
                                # elif SPACE_DIMS == 3
                                    {1,1,1};
                                # endif

int s_MPI_block_coords [SPACE_DIMS] =

    # if defined (ENABLE_MPI)

        # if SPACE_DIMS == 1
            {-1};
        # elif SPACE_DIMS == 2
            {-1,-1};
        # elif SPACE_DIMS == 3
            {-1,-1,-1};
        # endif

    # else // if defined (ENABLE_MPI)

        # if SPACE_DIMS == 1
            {0};
        # elif SPACE_DIMS == 2
            {0,0};
        # elif SPACE_DIMS == 3
            {0,0,0};
        # endif

    #endif // if defined (ENABLE_MPI)


//------------------------------------------------------------------------------------------------------------
//! \brief  Print help message with summary of all routines and exit.
//------------------------------------------------------------------------------------------------------------
static void PrintHelp ( void ) {

# if LOGLEVEL >= 3
    std::cerr << __GRN << "STATUS: " << __RESET << "[" << __FILE__ << ":" << __LINE__ << "]  "
              << "Printing help message."
              << std::endl;
# endif

    const std::string sha( reinterpret_cast<const char *>( src_sha ), src_sha_len );

    std::cout
        << std::endl
        << " Version: " << sha << std::endl
        << std::endl
        << " ================================================================================"  << std::endl
        << " === ANGULAR FLUX ROUTINES ======================================================"  << std::endl
        << " ================================================================================"  << std::endl
        << std::endl
        << "Basic outputs:"                                                                     << std::endl
        << "    ./postproc.x af_print <filename>"                                               << std::endl
        << "    ./postproc.x af_plot <filename> <output_filename>"                              << std::endl
        << std::endl
        << "Norms and Distances:"                                                               << std::endl
        << "    ./postproc.x af_norm <norm> <filename>"                                         << std::endl

# if (SPACE_DIMS == 1)
        << "    ./postproc.x af_dist <norm> <filename1> <filename2>"                            << std::endl
        << "    ./postproc.x af_mom_dist <norm> <filename1> <filename2>"                        << std::endl
        << "    ./postproc.x af_convergence <norm> <ref_filename> <file_prefix>"                << std::endl
        << "    ./postproc.x af_cauchy <norm> <file_prefix>"                                    << std::endl
        << "    ./postproc.x af_data_table <ref_prefix>"                                        << std::endl
# endif

        << std::endl
        << " ================================================================================"  << std::endl
        << " === SCALAR DENSITY ROUTINES ===================================================="  << std::endl
        << " ================================================================================"  << std::endl
        << std::endl
        << "Basic outputs:"                                                                     << std::endl
        << "    ./postproc.x sd_print <filename>"                                               << std::endl
        << "    ./postproc.x sd_plot <filename> <output_filename>"                              << std::endl
# ifndef ENABLE_MPI
        << "    ./postproc.x sd_cell_bin <filename> <output_filename>"                          << std::endl
# endif
        << "    ./postproc.x sd_convert <filename> <version>"                                   << std::endl
        << "    ./postproc.x sd_plot_diff <filename1> <filename2> <output_filename>"            << std::endl
        << std::endl
        << "Norms and Distances:"                                                               << std::endl
        << "    ./postproc.x sd_norm <norm> <filename>"                                         << std::endl
        << "    ./postproc.x sd_dist <norm> <filename1> <filename2>"                            << std::endl
        << "    ./postproc.x sd_convergence <norm> <ref_filename> <file_prefix>"                << std::endl
        << "    ./postproc.x sd_cauchy <norm> <file_prefix>"                                    << std::endl
        << "    ./postproc.x sd_data_table <ref_prefix>"                                        << std::endl
        << std::endl;

}


//------------------------------------------------------------------------------------------------------------
//! \brief  Returns the runtype from a filename string.
//!
//! \param[in]      filename    Filename to parse runtype from.
//!
//! \return     Returns the substring containing the runtype parsed from the given input string \pp{filename}.
//------------------------------------------------------------------------------------------------------------
static std::string RunType (

    const std::string filename
) {

    size_t u_score = filename.find_first_of( "_", 0 );

    return filename.substr( 0, u_score );
}


//------------------------------------------------------------------------------------------------------------
//! \brief  Returns the convergence order from a filename string.
//!
//! \param[in]      filename    Filename to parse convergence order from
//!
//! \return     Returns the substring containing the convergence order parsed from the given input string
//!             \pp{filename}.
//------------------------------------------------------------------------------------------------------------
static std::string Order (

    const std::string filename
) {

    size_t u_score1 = filename.find_first_of( "_", 0           );
    size_t u_score2 = filename.find_first_of( "_", u_score1 +1 );

    return filename.substr( u_score1 +1, u_score2 - u_score1 -1 );
}


//------------------------------------------------------------------------------------------------------------
//! \brief  Returns the angular order from a filename string.
//!
//! \param[in]      filename    Filename to parse angular order from.
//!
//! \return     Returns the substring containing the angular order parsed from the given input string
//!             \pp{filename}.
//------------------------------------------------------------------------------------------------------------
static std::string Angles (

    const std::string filename
) {

    size_t u_score1 = filename.find_first_of( "_", 0           );
    size_t u_score2 = filename.find_first_of( "_", u_score1 +1 );
    size_t u_score3 = filename.find_first_of( "_", u_score2 +1 );

    return filename.substr( u_score2 +1, u_score3 - u_score2 -1 );
}


//------------------------------------------------------------------------------------------------------------
//! \brief  Returns the number of spatial cells from a filename string.
//!
//! \param[in]      filename    Filename to parse number of spatial cells from.
//!
//! \return     Returns the substring containing the number of spatial cells parsed from the given input
//!             string \pp{filename}.
//------------------------------------------------------------------------------------------------------------
static std::string Cells (

    const std::string filename
) {

    size_t period = filename.find_last_of( ".", filename.size() );
    size_t u_score = filename.find_last_of( "_", period );

    return filename.substr( u_score +1, period - u_score -1 );
}


//------------------------------------------------------------------------------------------------------------
//! \brief  Returns the runname from a filename string.
//!
//! The runname is a string composed of the runtype and angular order.
//!
//! \param[in]      filename    Filename to parse and construct runname from.
//!
//! \return     Returns the runname constructed from the given input string \pp{filename}.
//------------------------------------------------------------------------------------------------------------
static std::string RunName (

    const std::string filename
) {
    return RunType(filename) + " " + Angles(filename);
}


//------------------------------------------------------------------------------------------------------------
//! \brief  Constructs data tables for timings, memory, and convergence in the L1, L2, and L-infinity norms.
//!
//! \param[in]  ref_prefix  Prefix of the filename for the reference solution.
//! \param[in]  suffix      Suffix for filenames of data files.
//------------------------------------------------------------------------------------------------------------
template< typename DensityType >
void DataTable (

    const std::string ref_prefix,
    const std::string suffix
) {

    int64_t ref_cells;

    std::string directory_name  = "./finished_jobs/";           // Subdirectory where data files are found.
    std::string out_dir_name    = "./convergence_data/";        // Subdirectory to output data tables to.
    std::string ref_name        = ref_prefix + "." + suffix;    // Filename of the reference solution data file.

    // Number of spatial cells in reference solution.
    std::stringstream( Cells( ref_name ).substr( 2, std::string::npos ) ) >> ref_cells;

    // Setup vector of norm keys.
    std::vector< std::string > norm_keys;
    norm_keys.push_back( "l1"   );
    norm_keys.push_back( "l2"   );
    norm_keys.push_back( "linf" );

    // Print out directory and reference file information.
    std::cout << "Data directory: " << directory_name << std::endl;
    std::cout << "Reference solution: " << ref_name << std::endl;


    // --- Make sorted list of data files in data file directory. ------------------------------------- //

    DIR * dir_ptr = opendir( directory_name.c_str() );

    if ( dir_ptr == nullptr )
    {
        std::string error_message = "Failed to open directory '" + directory_name + "' in '"
                                  + std::string(__func__) + "'.\n";

        PRINT_ERROR( error_message.c_str() )
        throw std::runtime_error( error_message );
    }

    std::vector< std::string > data_files;
    std::string filename;

    {
        struct dirent * file = nullptr;

        while ( (file = readdir(dir_ptr)) != nullptr ) {

            filename = std::string( file->d_name );

            if (    filename.size() > suffix.size()
                 && !filename.compare( filename.size() - suffix.size(), suffix.size(), suffix )
            ) {
                data_files.push_back( filename );
            }
        }
        closedir( dir_ptr );
    }

    std::sort( data_files.begin(), data_files.end() );


    // --- Search list for the reference solution. If not found, exit. -------------------------------- //

    if ( std::find( data_files.begin(), data_files.end(), ref_name ) == data_files.end() ) {

        std::string error_message = "Unable to find reference solution '" + ref_name + "' in '"
                                    + std::string(__func__) + "'.\n";

        PRINT_ERROR( error_message.c_str() )
        throw std::runtime_error( error_message );
    }


    // --- Get information about set of solutions. ---------------------------------------------------- //
    //
    // This includes:
    //
    //  1. Range of spatial cells used by solutions.
    //  2. Runtypes of solutions present.
    //  3. Convergence orders of runs.
    //

    std::string curr_key;
    std::vector< std::string > run_keys;
    std::vector< std::string > cell_keys;
    std::vector< std::string > order_keys;
    std::vector< std::string >::iterator key_iter;

    for ( std::vector< std::string >::iterator file = data_files.begin();
          file != data_files.end();
          ++file
    ) {

        // List of spatial cells.
        curr_key = Cells( *file );

        key_iter = std::find( cell_keys.begin(), cell_keys.end(), curr_key );
        if ( key_iter == cell_keys.end() )
            cell_keys.push_back( curr_key );

        // List of run types.
        curr_key = RunName( *file );

        key_iter = std::find( run_keys.begin(), run_keys.end(), curr_key );
        if ( key_iter == run_keys.end() )
            run_keys.push_back( curr_key );

        // List of convergence orders.
        curr_key = Order( *file );

        key_iter = std::find( order_keys.begin(), order_keys.end(), curr_key );
        if ( key_iter == order_keys.end() )
            order_keys.push_back( curr_key );
    }

    // Sort all lists.
    std::sort( run_keys.begin(),   run_keys.end()   );
    std::sort( cell_keys.begin(),  cell_keys.end()  );
    std::sort( order_keys.begin(), order_keys.end() );

//     // Print the lists.
//     for ( std::vector< std::string >::iterator key = run_keys.begin();
//           key != run_keys.end();
//           ++key
//     ) {
//         std::cout << key - run_keys.begin() << " " << *key << std::endl;
//     }
//
//     for ( std::vector<std::string>::iterator key = cell_keys.begin();
//           key != cell_keys.end();
//           ++key
//     ) {
//         std::cout << key - cell_keys.begin() << " " << *key << std::endl;
//     }
//
//     for ( std::vector<std::string>::iterator key = order_keys.begin();
//           key != order_keys.end();
//           ++key
//     ) {
//         std::cout << key - order_keys.begin() << " " << *key << std::endl;
//     }


    DensityType ref {};
    DensityType approx {};
    DensityType diff {};

    NDArray<double> errors( { order_keys.size(), run_keys.size(), cell_keys.size(), norm_keys.size() } );
    NDArray<double> times ( { order_keys.size(), run_keys.size(), cell_keys.size() } );

    for ( uint64_t o = 0; o < order_keys.size(); ++o ) {
    for ( uint64_t r = 0; r < run_keys.size();   ++r ) {
    for ( uint64_t c = 0; c < cell_keys.size();  ++c ) {
    for ( uint64_t n = 0; n < norm_keys.size();  ++n ) {

        errors.at({o,r,c,n}) = std::nan("0");
    }}}}

    std::cout << std::setw(24) << std::setprecision(16) << std::scientific;

    // Read reference solution from file.
    ref.ReadFromDisk( directory_name + ref_name );


    // --- Read in each solution, compare to reference solution, and store the errors. ---------------- //

    for ( std::vector< std::string >::iterator file = data_files.begin();
          file != data_files.end();
          ++file
    ) {

        PRINT_LOG( "Processing file %s.\n", (*file).c_str() )

        // order, run, cell -- keys indices for current data file.
        uint64_t o = std::find( order_keys.begin(), order_keys.end(), Order(*file)   ) - order_keys.begin();
        uint64_t r = std::find( run_keys.begin(),   run_keys.end(),   RunName(*file) ) - run_keys.begin();
        uint64_t c = std::find( cell_keys.begin(),  cell_keys.end(),  Cells(*file)   ) - cell_keys.begin();

        // Read solution from file.
        approx.ReadFromDisk( directory_name + (*file) );

        // Compute difference between solution and reference solution.
        DensityType::ComputeDifference( ref, approx, diff );

        // Compute norms of difference (i.e., errors).
        errors.at({o,r,c,0}) = diff.L1Norm();
        errors.at({o,r,c,1}) = diff.L2Norm();
        errors.at({o,r,c,2}) = diff.LinfNorm();

        // Get solution runtime from log file.
        std::string line;
        double temp;

        std::string log_filename = *file;
        log_filename.replace( log_filename.end() - 3, log_filename.end(), "log" );

        std::ifstream log_file( directory_name + log_filename, std::ios::in );

        if ( !log_file.is_open() ) {

            PRINT_ERROR( "Error opening text file '%s'.\n", log_filename.c_str() )

            times.at({o,r,c}) = 0.0;

        } else {

            // Get runtime.
            while (    getline( log_file, line )
                    && line.find( "Solve Seconds" ) == std::string::npos
            ) {}

            if ( log_file.eof() ) {

                PRINT_ERROR( "Unable to find runtime in file '%s'.\n", log_filename.c_str() )

                temp = 0.0;

            } else std::sscanf( line.c_str(), "  Solve Seconds:%la", &temp );

            times.at({o,r,c}) = temp;

            // Close text file.
            log_file.close();
        }
    }


    // --- For each run key, print it's table. -------------------------------------------------------- //

    std::ofstream data_file;
    const size_t small_width = 15;

    for ( uint64_t r = 0; r < run_keys.size(); ++r ) {

        filename = out_dir_name + run_keys[r] + "_" + suffix + ".dat";

        // Open file for writing.
        data_file.open( filename );

        data_file << std::setprecision(6) << std::scientific;

        // Print first row of table.
        data_file << std::setw(small_width -1) << "nx";

        for ( std::vector< std::string >::iterator ord_iter = order_keys.begin();
              ord_iter != order_keys.end();
              ++ord_iter
        ) {

            data_file << std::setw(small_width) << (*ord_iter) + "_" + "time";

            for ( uint64_t n = 0; n < norm_keys.size(); ++n ) {

                switch (n) {

                    case 0 :
                        data_file << std::setw(small_width) << (*ord_iter) + "_" + "L1";
                        break;

                    case 1 :
                        data_file << std::setw(small_width) << (*ord_iter) + "_" + "L2";
                        break;

                    case 2 :
                        data_file << std::setw(small_width) << (*ord_iter) + "_" + "Linf";
                        break;
                }
            }
        }

        data_file << std::endl;

        // Print data rows of file.
        for ( uint64_t c = 0; c < cell_keys.size(); ++c ) {

            // Print number of cells for row.
            data_file << std::setw(small_width) << cell_keys[c].substr(2);

            // Print error values and runtime.
            for ( uint64_t o = 0; o < order_keys.size(); ++o ) {

                data_file << std::setw(small_width) << times.at({o,r,c});

            for ( uint64_t n = 0; n < norm_keys.size(); ++n ) {

                if ( std::isfinite( errors.at({o,r,c,n}) ) ) {

                    data_file << std::setw(small_width) << errors.at({o,r,c,n});

                } else {

                    data_file << std::setw(small_width) << 0.0;
                }
            }}

            data_file << std::endl;
        }

        // Close file.
        data_file.close();
    }
}


//------------------------------------------------------------------------------------------------------------
//! \brief  Runs a convergence test on a set of objects by comparing each solution to a given reference
//!         solution.
//!
//! The convergence test is run using the norm(s) specified by \pp{norm}.
//! A table summarizing the results of the convergence test is printed to stdout.
//!
//! \param[in]      reference_filename  Name of file containing the reference solution.
//! \param[in]      prefix              Prefix used for filenames of approximate solutions used in convergence
//!                                     test.
//! \param[in]      suffix              Suffix used for filenames of approximate solutions used in convergence
//!                                     test.
//! \param[in]      norm_type           Specifies the norm(s) to use for the convergence test.
//------------------------------------------------------------------------------------------------------------
template< typename DensityType >
void ReferenceConvergence (

    const std::string reference_filename,
    const std::string prefix,
    const std::string suffix,
    const std::string norm_type
) {

    DensityType reference {};
    DensityType approximate {};
    DensityType difference {};

    std::string directory_name, filename_prefix;
    std::vector< std::string > data_files;

    int64_t cells_last = 0;
    double norm = 0.0, norm_last = 0.0;
    double norms [] = { 0.0, 0.0, 0.0 };
    double norms_last [] = { 0.0, 0.0, 0.0 };

    std::cout << std::endl
              << "Using reference solution: " << reference_filename
              << std::endl;


    // --- Find data files of approximate solutions for convergence test using given prefix. ---------- //

    // First parse prefix for directory name and filename prefix.
    std::string::size_type directory_index = prefix.find_last_of( '/' );

    // If forward slash IS NOT found, just use current directory.
    if ( directory_index == std::string::npos ) {

        directory_name = "./";
        filename_prefix = prefix;

    // If forward slash IS found, parse out directory name.
    } else {

        directory_name = prefix.substr( 0, directory_index+1 );
        filename_prefix = prefix.substr( directory_index+1 );
    }

    std::cout << "Searching directory '" << directory_name
              << "' for files with prefix '" << filename_prefix
              << "' and suffix '" << suffix << "'." << std::endl;

    // Search directory for files with given filename prefix.
    DIR * dir_ptr = opendir( directory_name.c_str() );
    struct dirent * file = nullptr;
    std::string filename;

    while ( (file = readdir(dir_ptr)) != nullptr ) {

        filename = std::string( file->d_name );

        if (    filename.size() > filename_prefix.size()
             && !filename.compare( 0, filename_prefix.size(), filename_prefix )
             && !filename.compare( filename.size() - suffix.size(), suffix.size(), suffix )
        ) {
            data_files.push_back( filename );
        }
    }

    closedir( dir_ptr );

    std::sort( data_files.begin(), data_files.end() );

    std::cout << std::endl << "Using approximate solutions:" << std::endl << std::endl;

    for ( auto const& data_file : data_files )
        std::cout << "\t" << directory_name << data_file << std::endl;

    std::cout << std::endl;

    // If no such files found, print error and return;
    if ( data_files.size() == 0 ) {

        std::string error_message = "No data files found in '" + std::string(__func__) + "'.\n";

        PRINT_ERROR( error_message.c_str() )
        throw std::runtime_error( error_message );
    }

    // --- Prepare to run convergence test. ----------------------------------------------------------- //

    // Print table header.
    if ( norm_type == "all" ) {

        std::cout << std::string( 84, '-' ) << std::endl
                  << " " << std::setw(Global::col_width) << "nx"         << " "
                  << " " << std::setw(Global::col_width) << "L1-error"   << " "
                  << " " << std::setw(Global::col_width) << "Rate L1"    << " "
                  << " " << std::setw(Global::col_width) << "L2-error"   << " "
                  << " " << std::setw(Global::col_width) << "Rate L2"    << " "
                  << " " << std::setw(Global::col_width) << "Linf-error" << " "
                  << " " << std::setw(Global::col_width) << "Rate Linf"  << " "
                  << std::endl << std::string( 84, '-' ) << std::endl;
    } else {

        std::cout << std::string( 36, '-' ) << std::endl
                  << " " << std::setw(Global::col_width) << "Cells" << " "
                  << " " << std::setw(Global::col_width) << "Error" << " "
                  << " " << std::setw(Global::col_width) << "Rate"  << std::endl
                  << std::string( 36, '-' ) << std::endl;
    }

    // Read reference solution from data file.
    reference.ReadFromDisk( reference_filename );

    // --- Run convergence test. ---------------------------------------------------------------------- //

    for ( auto const& data_file : data_files ) {

        // Read approximate solution from data file.
        approximate.ReadFromDisk( directory_name + data_file );

        // Compute difference between approximate and reference solutions.
        DensityType::ComputeDifference( reference, approximate, difference );

        // Compute norm and output result to table.
        if ( norm_type == "all" ) {

            norms[0] = difference.L1Norm();
            norms[1] = difference.L2Norm();
            norms[2] = difference.LinfNorm();

            if ( data_file == *data_files.begin() ) {

                std::cout << " " << std::setw(Global::col_width) << approximate.nx(0) << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[0] << " "
                          << " " << std::setw(Global::col_width) << "----" << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[1] << " "
                          << " " << std::setw(Global::col_width) << "----" << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[2] << " "
                          << " " << std::setw(Global::col_width) << "----" << " "
                          << std::endl;
            } else {

                std::cout << " " << std::setw(Global::col_width) << approximate.nx(0) << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[0] << " "
                          << " " << std::setw(Global::col_width) << std::fixed
                                 << ( std::log( norms_last[0] / norms[0] )
                                    / std::log( (double) approximate.nx(0) / cells_last ) )
                                 << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[1] << " "
                          << " " << std::setw(Global::col_width) << std::fixed
                                 << ( std::log( norms_last[1] / norms[1] )
                                    / std::log( (double) approximate.nx(0) / cells_last ) )
                                 << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[2] << " "
                          << " " << std::setw(Global::col_width) << std::fixed
                                 << ( std::log( norms_last[2] / norms[2] )
                                    / std::log( (double) approximate.nx(0) / cells_last ) )
                                 << " "
                          << std::endl;
            }

            norms_last[0] = norms[0];
            norms_last[1] = norms[1];
            norms_last[2] = norms[2];

        } else {

            if ( norm_type == "L1" )
                norm = difference.L1Norm();
            else if ( norm_type == "L2" )
                norm = difference.L2Norm();
            else if ( norm_type == "Linf" )
                norm = difference.LinfNorm();

            if ( data_file == *data_files.begin() ) {

                std::cout << " " << std::setw(Global::col_width) << approximate.nx(0) << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norm << " "
                          << " " << std::setw(Global::col_width) << "----"
                          << std::endl;
            } else {

                std::cout << " " << std::setw(Global::col_width) << approximate.nx(0) << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norm << " "
                          << " " << std::setw(Global::col_width) << std::fixed
                                 << ( std::log( norm_last / norm )
                                    / std::log( (double) approximate.nx(0) / cells_last ) )
                          << std::endl;
            }

            norm_last = norm;
        }

        cells_last = approximate.nx(0);
    }
}


//------------------------------------------------------------------------------------------------------------
//! \brief  Runs a convergence test on a set of objects by comparing successive solutions.
//!
//! The convergence test is run using the norm(s) specified by \pp{norm}.
//! A table summarizing the results of the convergence test is printed to stdout.
//!
//! \param[in]      prefix      Prefix used for filenames of approximate solutions used in convergence test.
//! \param[in]      suffix      Suffix used for filenames of approximate solutions used in convergence test.
//! \param[in]      norm_type   Specifies the norm(s) to use for the convergence test.
//------------------------------------------------------------------------------------------------------------
template< typename DensityType >
void CauchyConvergence (

    const std::string prefix,
    const std::string suffix,
    const std::string norm_type
) {

    DensityType coarse {};
    DensityType fine {};
    DensityType diff {};

    std::string directory_name, filename_prefix;
    std::vector< std::string > data_files;

    int64_t cells_last = 0;
    double norm = 0.0, norm_last = 0.0;
    double norms [] = { 0.0, 0.0, 0.0 };
    double norms_last [] = { 0.0, 0.0, 0.0 };


    // --- Find data files of approximate solutions for convergence test using given prefix. ---------- //

    // First parse prefix for directory name and filename prefix.
    std::string::size_type directory_index = prefix.find_last_of( '/' );

    // If forward slash IS NOT found, just use current directory.
    if ( directory_index == std::string::npos ) {

        directory_name = "./";
        filename_prefix = prefix;

    // If forward slash IS found, parse out directory name.
    } else {

        directory_name = prefix.substr( 0, directory_index+1 );
        filename_prefix = prefix.substr( directory_index+1 );
    }

    std::cout << "Searching directory '" << directory_name
              << "' for files with prefix '" << filename_prefix
              << "' and suffix '" << suffix << "'." << std::endl;

    // Search directory for files with given filename prefix.
    DIR * dir_ptr = opendir( directory_name.c_str() );
    struct dirent * file = nullptr;
    std::string filename;

    while ( (file = readdir(dir_ptr)) != nullptr ) {

        filename = std::string( file->d_name );

        if (    filename.size() > filename_prefix.size()
             && !filename.compare( 0, filename_prefix.size(), filename_prefix )
             && !filename.compare( filename.size() - suffix.size(), suffix.size(), suffix )
        ) {
            data_files.push_back( filename );
        }
    }

    closedir( dir_ptr );

    std::sort( data_files.begin(), data_files.end() );

    std::cout << std::endl << "Using approximate solutions:" << std::endl << std::endl;

    for ( auto const& data_file : data_files )
        std::cout << "\t" << directory_name << data_file << std::endl;

    std::cout << std::endl;

    // If no such files found, print error and return;
    if ( data_files.size() == 0 ) {

        std::string error_message = "No data files found in '" + std::string(__func__) + "'.\n";

        PRINT_ERROR( error_message.c_str() )
        throw std::runtime_error( error_message );
    }

    // --- Prepare to run convergence test. ----------------------------------------------------------- //

    // Print table header.
    if ( norm_type == "all" ) {

        std::cout << std::string( 84, '-' ) << std::endl
                  << " " << std::setw(Global::col_width) << "nx"         << " "
                  << " " << std::setw(Global::col_width) << "L1-error"   << " "
                  << " " << std::setw(Global::col_width) << "Rate L1"    << " "
                  << " " << std::setw(Global::col_width) << "L2-error"   << " "
                  << " " << std::setw(Global::col_width) << "Rate L2"    << " "
                  << " " << std::setw(Global::col_width) << "Linf-error" << " "
                  << " " << std::setw(Global::col_width) << "Rate Linf"  << " "
                  << std::endl << std::string( 84, '-' ) << std::endl;
    } else {

        std::cout << std::string( 36, '-' ) << std::endl
                  << " " << std::setw(Global::col_width) << "Cells" << " "
                  << " " << std::setw(Global::col_width) << "Error" << " "
                  << " " << std::setw(Global::col_width) << "Rate"  << std::endl
                  << std::string( 36, '-' ) << std::endl;
    }


    // --- Run convergence test. ---------------------------------------------------------------------- //

    for ( uint64_t i = 0; i < data_files.size() - 1; ++i ) {

        // Read approximate solutions from data files.
        coarse.ReadFromDisk( directory_name + data_files[i] );
        fine.ReadFromDisk( directory_name + data_files[i+1] );

        // Compute difference between coarse and fine solutions.
        DensityType::ComputeDifference( coarse, fine, diff );

        if ( norm_type == "all" ) {

            norms[0] = diff.L1Norm();
            norms[1] = diff.L2Norm();
            norms[2] = diff.LinfNorm();

            if ( i == 0 ) {

                std::cout << " " << std::setw(Global::col_width) << coarse.nx(0) << " "
                          << " " << std::setw(Global::col_width) << "--------" << " "
                          << " " << std::setw(Global::col_width) << "----" << " "
                          << " " << std::setw(Global::col_width) << "--------" << " "
                          << " " << std::setw(Global::col_width) << "----" << " "
                          << " " << std::setw(Global::col_width) << "--------" << " "
                          << " " << std::setw(Global::col_width) << "----" << " "
                          << std::endl;

                std::cout << " " << std::setw(Global::col_width) << fine.nx(0) << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[0] << " "
                          << " " << std::setw(Global::col_width) << "----" << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[1] << " "
                          << " " << std::setw(Global::col_width) << "----" << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[2] << " "
                          << " " << std::setw(Global::col_width) << "----" << " "
                          << std::endl;
            } else {

                std::cout << " " << std::setw(Global::col_width) << fine.nx(0) << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[0] << " "
                          << " " << std::setw(Global::col_width) << std::fixed
                                 << ( std::log( norms_last[0] / norms[0] )
                                    / std::log( (double) fine.nx(0) / cells_last ) )
                                 << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[1] << " "
                          << " " << std::setw(Global::col_width) << std::fixed
                                 << ( std::log( norms_last[1] / norms[1] )
                                    / std::log( (double) fine.nx(0) / cells_last ) )
                                 << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norms[2] << " "
                          << " " << std::setw(Global::col_width) << std::fixed
                                 << ( std::log( norms_last[2] / norms[2] )
                                    / std::log( (double) fine.nx(0) / cells_last ) )
                                 << " "
                          << std::endl;
            }

            norms_last[0] = norms[0];
            norms_last[1] = norms[1];
            norms_last[2] = norms[2];

        } else {

            if ( norm_type == "L1" )
                norm = diff.L1Norm();
            else if ( norm_type == "L2" )
                norm = diff.L2Norm();
            else if ( norm_type == "Linf" )
                norm = diff.LinfNorm();

            if ( i == 0 ) {

                std::cout << " " << std::setw(Global::col_width) << coarse.nx(0) << " "
                          << " " << std::setw(Global::col_width) << "--------" << " "
                          << " " << std::setw(Global::col_width) << "----"
                          << std::endl;

                std::cout << " " << std::setw(Global::col_width) << fine.nx(0) << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norm << " "
                          << " " << std::setw(Global::col_width) << "----"
                          << std::endl;
            } else {

                std::cout << " " << std::setw(Global::col_width) << fine.nx(0) << " "
                          << " " << std::setw(Global::col_width) << std::scientific << std::setprecision(2)
                                 << norm << " "
                          << " " << std::setw(Global::col_width) << std::fixed
                                 << ( std::log( norm_last / norm )
                                    / std::log( (double) fine.nx(0) / cells_last ) )
                          << std::endl;
            }

            norm_last = norm;
        }

        cells_last = fine.nx(0);
    }
}


//------------------------------------------------------------------------------------------------------------
//! \brief  main
//!
//------------------------------------------------------------------------------------------------------------
int main (

    int argc,
    char ** argv
) {

    // Parameters required for lookup.
    Global::input_list = {{
        # if SPACE_DIMS == 1
            { "relabel_type",   RelabelOperator::RelabelType_to_String.at( RelabelOperator::RelabelType::PolyInterp )  }
        # endif
        }};


# if defined (ENABLE_MPI)

    int required = MPI_THREAD_MULTIPLE;
    int provided = -1;

    MPI_Init_thread( &argc, &argv, required, &provided );

    MPI_Comm_size( MPI_COMM_WORLD, &Global::MPI_num_ranks );
    MPI_Comm_rank( MPI_COMM_WORLD, &Global::MPI_rank );

    if ( provided < required )
        PRINT_WARNING( "Thread support provided by MPI library (%d) is less than requested (%d).\n",
                       provided, required )

    if ( Global::MPI_num_ranks > 1 ) {

        PRINT_ERROR( "Implementation of post-processing routines not designed for use with multiple MPI tasks.\n" )
        MPI_Abort( MPI_COMM_WORLD, EXIT_FAILURE );
    }

    int periods [SPACE_DIMS] =
                            # if SPACE_DIMS == 1
                                {0};
                            # elif SPACE_DIMS == 2
                                {0,0};
                            # elif SPACE_DIMS == 3
                                {0,0,0};
                            # endif

    int MPI_err = MPI_Cart_create( MPI_COMM_WORLD, SPACE_DIMS, s_MPI_num_blocks, periods, 1,
                                   &Global::MPI_cart_comm );

    if ( MPI_err ) {

        PRINT_ERROR( "MPI_Cart_create returned %d. Aborting run.\n", MPI_err )
        MPI_Abort( MPI_COMM_WORLD, EXIT_FAILURE );
    }

    MPI_Cart_coords( Global::MPI_cart_comm, Global::MPI_rank, SPACE_DIMS, s_MPI_block_coords );

# endif // if defined (ENABLE_MPI)


# if defined (ENABLE_HWLOC)

    // Get machine topology configuration.
    hwloc_topology_init( &Global::machine_topology );
    hwloc_topology_load( Global::machine_topology );

    Global::active_core_mask = hwloc_bitmap_alloc();

    int num_threads
        # if defined (_OPENMP)
            = omp_get_max_threads();
        # else
            = 1;
        # endif

    Global::thread_masks = (hwloc_cpuset_t *) std::malloc( num_threads * sizeof(hwloc_cpuset_t) );

    // Get per-thread core bindings.
    # pragma omp parallel
    {
        int tid
            # if defined (_OPENMP)
                = omp_get_thread_num();
            # else
                = 0;
            # endif

        Global::thread_masks[tid] = hwloc_bitmap_alloc();
        hwloc_get_cpubind( Global::machine_topology, Global::thread_masks[tid], HWLOC_CPUBIND_THREAD );

        # pragma omp critical
        hwloc_bitmap_or( Global::active_core_mask, Global::active_core_mask, Global::thread_masks[tid] );
    }

# endif // if defined (ENABLE_HWLOC)


    if (    argc == 1
         || std::string( argv[1] ) == "help"
    ) {

        PrintHelp();
        std::exit( EX_OK );


    // --- Angular flux norm. ------------------------------------------------------------------------- //

    } else if ( std::string( argv[1] ) == "af_norm" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 4;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Computing norm(s) of angular flux.\n" )

        OrdinateFlux data {};

        data.ReadFromDisk( argv[3] );

        if ( std::string( argv[2] ) == "l1" )
            std::cout << std::scientific << std::setprecision(3) << data.l1Norm();

        else if ( std::string( argv[2] ) == "l2" )
            std::cout << std::scientific << std::setprecision(3) << data.l2Norm();

        else if ( std::string( argv[2] ) == "linf" )
            std::cout << std::scientific << std::setprecision(3) << data.linfNorm();

        else if ( std::string( argv[2] ) == "L1" )
            std::cout << std::scientific << std::setprecision(3) << data.L1Norm();

        else if ( std::string( argv[2] ) == "L2" )
            std::cout << std::scientific << std::setprecision(3) << data.L2Norm();

        else if ( std::string( argv[2] ) == "Linf" )
            std::cout << std::scientific << std::setprecision(3) << data.LinfNorm();

        else if ( std::string( argv[2] ) == "all" ) {

            std::cout << "l1   = "
                      << std::scientific << std::setprecision(3) << data.l1Norm()   << std::endl
                      << "l2   = "
                      << std::scientific << std::setprecision(3) << data.l2Norm()   << std::endl
                      << "linf = "
                      << std::scientific << std::setprecision(3) << data.linfNorm() << std::endl
                      << "L1   = "
                      << std::scientific << std::setprecision(3) << data.L1Norm()   << std::endl
                      << "L2   = "
                      << std::scientific << std::setprecision(3) << data.L2Norm()   << std::endl
                      << "Linf = "
                      << std::scientific << std::setprecision(3) << data.LinfNorm() << std::endl;

        } else {  goto malformed_command;  }

        std::exit( EX_OK );


    // --- Angular flux distance. --------------------------------------------------------------------- //

# if (SPACE_DIMS == 1)

    } else if ( std::string( argv[1] ) == "af_dist" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 5;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Computing distance between angular flux densities.\n" )

        OrdinateFlux data1 {};
        OrdinateFlux data2 {};
        OrdinateFlux diff {};

        data1.ReadFromDisk( argv[3] );
        data2.ReadFromDisk( argv[4] );

        OrdinateFlux::ComputeDifference( data1, data2, diff );

        if ( std::string( argv[2] ) == "L1" )
            std::cout << std::scientific << std::setprecision(3) << diff.L1Norm();

        else if ( std::string( argv[2] ) == "L2" )
            std::cout << std::scientific << std::setprecision(3) << diff.L2Norm();

        else if ( std::string( argv[2] ) == "Linf" )
            std::cout << std::scientific << std::setprecision(3) << diff.LinfNorm();

        else if ( std::string( argv[2] ) == "all" ) {

            std::cout << "L1   = "
                      << std::scientific << std::setprecision(3) << diff.L1Norm()   << std::endl
                      << "L2   = "
                      << std::scientific << std::setprecision(3) << diff.L2Norm()   << std::endl
                      << "Linf = "
                      << std::scientific << std::setprecision(3) << diff.LinfNorm() << std::endl;

        } else {  goto malformed_command;  }

        std::exit( EX_OK );

# endif // if (SPACE_DIMS == 1)


    // --- Distance between angular flux moments. ----------------------------------------------------- //

# if (SPACE_DIMS == 1)

    } else if ( std::string( argv[1] ) == "af_mom_dist" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 5;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Computing distance between angular flux densities.\n" )

        OrdinateFlux data1 {};
        OrdinateFlux data2 {};

        data1.ReadFromDisk( argv[3] );
        data2.ReadFromDisk( argv[4] );

        double (RKDG::DensityFunction::*norm)() const;

        if      ( std::string( argv[2] ) == "L1"   ) {  norm = &RKDG::DensityFunction::L1Norm;    }
        else if ( std::string( argv[2] ) == "L2"   ) {  norm = &RKDG::DensityFunction::L2Norm;    }
//      else if ( std::string( argv[2] ) == "Linf" ) {  norm = &RKDG::DensityFunction::LinfNorm;  } NOTE: Wrong pointer type.
        else                                         {  goto malformed_command;                   }

        auto distances = OrdinateFlux::ComputeMomentDistances( data1, data2, norm );

        for ( double dist : distances )
            std::cout << std::scientific << std::setprecision(3) << dist << " ";

        std::cout << std::endl;

        std::exit( EX_OK );

# endif // if (SPACE_DIMS == 1)


    // --- Angular flux convergence using reference solution. ----------------------------------------- //

# if (SPACE_DIMS == 1)

    } else if ( std::string( argv[1] ) == "af_convergence" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 5;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        const std::string norm_type = argv[2];

        if (    norm_type != "L1"
             && norm_type != "L2"
             && norm_type != "Linf"
             && norm_type != "all"
        ) {
            goto malformed_command;
        }

        PRINT_STATUS( "Running angular flux convergence test.\n" )

        ReferenceConvergence<OrdinateFlux>( argv[3], argv[4], "af" + std::to_string( SPACE_DIMS ), norm_type );

        std::exit( EX_OK );

# endif // if (SPACE_DIMS == 1)


    // --- Angular flux convergence using successive comparison. -------------------------------------- //

# if (SPACE_DIMS == 1)

    } else if ( std::string( argv[1] ) == "af_cauchy" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 4;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        const std::string norm_type = argv[2];

        if (    norm_type != "L1"
             && norm_type != "L2"
             && norm_type != "Linf"
             && norm_type != "all"
        ) {
            goto malformed_command;
        }

        PRINT_STATUS( "Running angular flux convergence test.\n" )

        CauchyConvergence<OrdinateFlux>( argv[3], "af" + std::to_string( SPACE_DIMS ), norm_type );

        std::exit( EX_OK );

# endif // if (SPACE_DIMS == 1)


    // --- Compute convergence data tables for angular fluxes. ---------------------------------------- //

# if (SPACE_DIMS == 1)

    } else if ( std::string( argv[1] ) == "af_data_table" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 3;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Computing angular flux convergence data table.\n" )

        DataTable<OrdinateFlux>( argv[2], "af" + std::to_string( SPACE_DIMS ) );

        std::exit( EX_OK );

# endif // if (SPACE_DIMS == 1)


    // --- Scalar density norm. ----------------------------------------------------------------------- //

    } else if ( std::string( argv[1] ) == "sd_norm" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 4;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Computing norm(s) of scalar density.\n" )

        DensityFunction data {};

        data.ReadFromDisk( argv[3] );

        if ( std::string( argv[2] ) == "l1" )
            std::cout << std::scientific << std::setprecision(3) << data.l1Norm();

        else if ( std::string( argv[2] ) == "l2" )
            std::cout << std::scientific << std::setprecision(3) << data.l2Norm();

        else if ( std::string( argv[2] ) == "linf" )
            std::cout << std::scientific << std::setprecision(3) << data.linfNorm();

        else if ( std::string( argv[2] ) == "L1" )
            std::cout << std::scientific << std::setprecision(3) << data.L1Norm();

        else if ( std::string( argv[2] ) == "L2" )
            std::cout << std::scientific << std::setprecision(3) << data.L2Norm();

        else if ( std::string( argv[2] ) == "Linf" )
            std::cout << std::scientific << std::setprecision(3) << data.LinfNorm();

        else if ( std::string( argv[2] ) == "all" ) {

            std::cout << "l1   = "
                      << std::scientific << std::setprecision(3) << data.l1Norm()   << std::endl
                      << "l2   = "
                      << std::scientific << std::setprecision(3) << data.l2Norm()   << std::endl
                      << "linf = "
                      << std::scientific << std::setprecision(3) << data.linfNorm() << std::endl
                      << "L1   = "
                      << std::scientific << std::setprecision(3) << data.L1Norm()   << std::endl
                      << "L2   = "
                      << std::scientific << std::setprecision(3) << data.L2Norm()   << std::endl
                      << "Linf = "
                      << std::scientific << std::setprecision(3) << data.LinfNorm() << std::endl;

        } else {  goto malformed_command;  }

        std::exit( EX_OK );


    // --- Scalar density distance. ------------------------------------------------------------------- //

    } else if ( std::string( argv[1] ) == "sd_dist" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 5;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Computing distance between scalar densities.\n" )

        DensityFunction data1 {};
        DensityFunction data2 {};
        DensityFunction diff {};

        data1.ReadFromDisk( argv[3] );
        data2.ReadFromDisk( argv[4] );

        DensityFunction::ComputeDifference( data1, data2, diff );

        if ( std::string( argv[2] ) == "L1" )
            std::cout << std::scientific << std::setprecision(3) << diff.L1Norm();

        else if ( std::string( argv[2] ) == "L2" )
            std::cout << std::scientific << std::setprecision(3) << diff.L2Norm();

        else if ( std::string( argv[2] ) == "Linf" )
            std::cout << std::scientific << std::setprecision(3) << diff.LinfNorm();

        else if ( std::string( argv[2] ) == "all" ) {

            std::cout << "L1   = "
                      << std::scientific << std::setprecision(3) << diff.L1Norm()   << std::endl
                      << "L2   = "
                      << std::scientific << std::setprecision(3) << diff.L2Norm()   << std::endl
                      << "Linf = "
                      << std::scientific << std::setprecision(3) << diff.LinfNorm() << std::endl;

        } else {  goto malformed_command;  }

        std::exit( EX_OK );


    // --- Scalar density convergence using reference solution. --------------------------------------- //

    } else if ( std::string( argv[1] ) == "sd_convergence" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 5;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        const std::string norm_type = argv[2];

        if (    norm_type != "L1"
             && norm_type != "L2"
             && norm_type != "Linf"
             && norm_type != "all"
        ) {
            goto malformed_command;
        }

        PRINT_STATUS( "Running scalar density convergence test.\n" )

        ReferenceConvergence<DensityFunction>( argv[3], argv[4], "sd" + std::to_string( SPACE_DIMS ),
                                               norm_type );

        std::exit( EX_OK );


    // --- Scalar density convergence using successive comparison. ------------------------------------ //

    } else if ( std::string( argv[1] ) == "sd_cauchy" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 4;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        const std::string norm_type = argv[2];

        if (    norm_type != "L1"
             && norm_type != "L2"
             && norm_type != "Linf"
             && norm_type != "all"
        ) {
            goto malformed_command;
        }

        PRINT_STATUS( "Running scalar density convergence test.\n" )

        CauchyConvergence<DensityFunction>( argv[3], "sd" + std::to_string( SPACE_DIMS ), norm_type );

        std::exit( EX_OK );


    // --- Compute convergence data tables for scalar densities. -------------------------------------- //

    } else if ( std::string( argv[1] ) == "sd_data_table" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 3;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Computing scalar density convergence data table.\n" )

        DataTable<DensityFunction>( argv[2], "sd" + std::to_string( SPACE_DIMS ) );

        std::exit( EX_OK );


    // --- Print angular flux parameters. ------------------------------------------------------------- //

    } else if ( std::string( argv[1] ) == "af_print" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 3;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Outputting parameters of angular flux.\n" )

        OrdinateFlux data {};

        data.ReadFromDisk( argv[2] );
        data.Print();

        std::exit( EX_OK );


    // --- Plot angular flux. ------------------------------------------------------------------------- //

    } else if ( std::string( argv[1] ) == "af_plot" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 4;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Outputting angular flux for plotting.\n" )

        OrdinateFlux data {};

        data.ReadFromDisk( argv[2] );
        data.OutputPlot( argv[3] );

        std::exit( EX_OK );


    // --- Print scalar density parameters. ----------------------------------------------------------- //

    } else if ( std::string( argv[1] ) == "sd_print" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 3;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Outputting parameters of scalar density.\n" )

        DensityFunction data {};

        data.ReadFromDisk( argv[2] );
        data.Print();

        std::exit( EX_OK );


    // --- Plot scalar density. ----------------------------------------------------------------------- //

    } else if ( std::string( argv[1] ) == "sd_plot" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 4;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Outputting scalar density for plotting.\n" )

        DensityFunction data {};

        data.ReadFromDisk( argv[2] );
        data.OutputPlot( argv[3] );

        std::exit( EX_OK );


    // --- Output scalar flux cell averages to binary file. ------------------------------------------- //

# ifndef ENABLE_MPI

    } else if ( std::string( argv[1] ) == "sd_cell_bin" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 4;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Outputting scalar density cell averages to binary file.\n" )

        DensityFunction data {};

        data.ReadFromDisk( argv[2] );
        data.OutputCellAveragesToBin( argv[3] );

        std::exit( EX_OK );

# endif // ifndef ENABLE_MPI


    // --- Plot difference between two scalar densities. ---------------------------------------------- //

    } else if ( std::string( argv[1] ) == "sd_plot_diff" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 5;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        PRINT_STATUS( "Outputting difference between scalar densities for plotting.\n" )

        DensityFunction data1 {};
        DensityFunction data2 {};

        data1.ReadFromDisk( argv[2] );
        data2.ReadFromDisk( argv[3] );

        DensityFunction::OutputDiffPlot( data1, data2, argv[4] );

        std::exit( EX_OK );


    // --- Convert old binary file to new format. ----------------------------------------------------- //

    } else if ( std::string( argv[1] ) == "sd_convert" ) {

        // Check for correct number of input arguments.
        const int64_t nargs = 4;
        if ( argc != nargs ) {

            PRINT_ERROR( "Wrong number of arguments. Expects %d got %" PRId64 ".\n", nargs, argc )
            std::exit( EX_USAGE );
        }

        // Get version number to convert from.
        int64_t version;

        if ( std::stringstream( argv[3] ) >> version ) {/* empty */}
        else
            throw std::runtime_error( "Failed to convert version string.\n" );

        PRINT_STATUS( "Converting old scalar density file to new format.\n" )

        DensityFunction data {};

        // Read old file.
        data.ReadFromDisk( argv[2], version );

        // Construct new filename.
        std::string filename = std::string( argv[2] ) + ".converted";

        // Write new file.
        data.WriteToDisk( filename );

        std::exit( EX_OK );


    // ================================================================================================ //
    // === UNKNOWN COMMAND ============================================================================ //
    // ================================================================================================ //

    } else {

malformed_command:

        PRINT_ERROR( "Malformed command.\n" )
        PrintHelp();
        std::exit( EX_USAGE );
    }
}
